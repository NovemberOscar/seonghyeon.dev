---
title: 우아한 Git 커밋 히스토리 유지하기
slug: keep-git-commit-history-elegant
author: Seonghyeon Kim
date: 2020-02-26
hero: ./images/title.jpg
excerpt: 역사는 승자에 의해 쓰여진다
---

저는 git hook 같은 도구로 퀄리티 필터를 사용하다 보면 퀄리티를 준수하지 못해 푸쉬가 안되는 경우가 있어서 포맷팅 등울 위해 간단히 코드를 고치는 경우가 있습니다. 

이때 단순하게 생각을 하자면 새로운 커밋을 생성할 수도 있지만 저는 깃 히스토리가 git blame 하기 편해야 한다고 생각하기 떄문에 저는 가급적 기존 커밋에 내용을 합쳐서 불필요한 내용들이 기록에 섞여들어가는 것을 막습니다. (물론 각 커밋들은 의미있는 단위로 유지해야 합니다.)

다음의 상황듫은 주로 제가 일을 하면서 맞닥트리는 상황들에 대한 제 자신의 표준적인 해결법들입니다.

## 상황 #1

> 나는 간단한 기능을 빠르게 만들고 커밋 `feat: A`를 만들었다. 그런데 푸쉬하려고 보니 최대 라인 제한을 넘은 코드가 있어서 다시 고쳐서 푸쉬하려고 한다.
>
> 그런데 `fix: lint violation` 같은 이름의 커밋을 만드는 것은 불필요한것 같다.

### 해결법

```bash
git commit --amend
```

가장 간단한 방법은 이전 커밋에 지금 스테이징된 내용을 합치는 것입니다. `--amend` 옵션은 이전 커밋에 지금 스테이징 되어 있는 작업을 합쳐줍니다.

## 상황 #2

> 나는 브랜치를 따서 규모가 있는 기능을 만들고, PR을 올려 리뷰를 받았다. 리뷰를 반영하고 원 브랜치에 머지하려고 하니 수정 커밋으로 인해 기능 규모에 비해 지나치게 많은 커밋이 포함되어 있다.
>
> 나는 커밋들을 합쳐서 머지하고 싶다.

이 경우에는 두가지 해결방법중에서 선택한다. 

### 해결법 A

```bash
git rebase -i HEAD~N
git push --force
```

```git
feat: A
feat: B
fix: A-1
fix: A-1-1
fix: B-1
fix: B-1-1
fix: B-1-2
```

A와 B에 대한 리뷰를 받고 커밋하고 머지하려고 보니 수정 커밋들끼리는 합쳐질만하면 이 해결방법을 적용합니다.

간단하게 interactive rebase 를 사용해서 `fix: A-1-1` 을 `fix: A` 로 squash 합니다. 그리고 `fix: B-1-*` 들도 `fix: B-1` 로 squash 하면 불필요하게 흩어진 fix 커밋들을 합쳐서 정리할 수 있습니다.

그 후 보통 이럴 경우는 리모트에 올라가 있는 브랜치를 건드리는 경우이기 떄문에 포스 푸쉬를 사용해 리모트 브랜치를 덮어씁니다.

### 해결법 B

이 해결법은 전체적으로 커밋 로그가 답이 없어 보여서 역사 조작을 **매우 많이** 하고 싶을때 사용합니다.

```
feat: A
fix: A-1
feat: B
fix: A-2
fix: B-1
fix: B-2
fix: B-3
Merge remote-tracking branch ...
fix: Reflect review on B-2
```

이런 커밋 히스토리가 있다고 가정해봅시다. fix 커밋이 굉장히 많고 여러가지 feat에 대해서 fix가 섞여있습니다. 게다가 fix 일부는 다시보니 새로운 feat C 로 묶는게 났다고까지 생각됩니다. 이럴 경우에는 이 꼬인 히스토리를 여러번에 걸쳐서 rebase 하는건 귀찮아서 저는 보통 꼬인 커밋히스토리들에 대해 기록말살형을 내리고 새롭게 역사를 쓰는 편입니다.

```bash
git reset --soft HEAD~N

# rewrite commits

git push --force
```

원하는 지점(보통은 브랜치의 처음) 까지 커밋을 리셋하지만 `--soft` 옵션을 사용해서 작업 내용을 보존합니다. 그 후 좋게 보인다고 생각하는 만큼 헝크를 묶어서 다시 커밋합니다. 

그 후 보통 이럴 경우는 리모트에 올라가 있는 브랜치를 건드리는 경우이기 떄문에 포스 푸쉬를 사용해 리모트 브랜치를 덮어씁니다.

## 상황 #3

> 신들린 작업을 하던 도중 다른 분이 먼저 푸쉬하신것을 발견했다. 이미 새로운 커밋을 만들었는데 그것때문에 새로운 머지 커밋을 만들면 그래프가 더러워질게 뻔하다.
>
> 나는 다른 분이 올리신 커밋과 내 커밋을 스무스하게 트리에 합치고 싶다.

이것도 두가지 방법이 있기 때문에 골라서 사용합니다.

### 해결법 A

```bash
git pull --rebase
```

보통의 경우에는 대부분 이 방법으로 해결이 가능합니다.

### 해결법 B

```bash
git reset --soft HEAD~N
git pull
```

다른 분이 올리신 커밋을 봤는데 딱뵈도 컨플릭트 각이 섰는데 컨플릭트 수정하는것보다 다시 커밋 쌓는게 편할것같으면 제가 올린 커밋을 다 리셋하고 풀 받은 다음 그 다음에 다시 커밋을 쌓는게 오히려 편해서 이런 괴상한 방법을 사용하기도 합니다.

## 상황 #4

> 또다시 신들린 작업을 하던 도중... 아차! 브랜치를 분리하는 것을 까먹었다!
>
> 나는 브랜치를 따로 분리해서 리뷰받고 나중에 Squash merge로 합치고 싶다.

### 해결법

git reset이 답이지만 이전에 리셋을 활용하던 것처럼 커밋을 다시 만들 필요는 없습니다.

```bash
git branch new-branch
git reset --hard HEAD~N   # at current branch
```